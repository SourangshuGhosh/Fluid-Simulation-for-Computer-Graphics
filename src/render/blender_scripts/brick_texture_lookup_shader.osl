/*
	This shader is used for looking up 'LEGO' brick colour data for
	brick positions generated by the PIC/FLIP Fluid Simulation 
	program's (https://github.com/rlguy/GridFluidSim3D) 'LEGO' brick 
	surface reconstruction feature.

	This shader is meant to be plugged into a Blender Cycles script node
	to convert global position to texture coordinate.
*/
	
int get_flat_index3d(int i, int j, int k, int width, int height) {
	return i + width * (j + height * k);
}
	
vector get_unflattened_index2d(int flatidx, int width) {
	int i = flatidx % width;
	int j = (int)floor((float)flatidx / (float)width);
	
	return vector(i, j, 0);
}

vector position_to_brick_index(vector pos, float bw, float bh, float bd) {
	return vector(floor(pos[0] / bw), floor(pos[1] / bh), floor(pos[2] / bd));
}

vector rotate_about_x(vector pos, float rads) {
	float x = pos[0];
	float y = pos[1]*cos(rads) - pos[2]*sin(rads);
	float z = pos[1]*sin(rads) + pos[2]*cos(rads);
	return vector(x, y, z);
}

vector rotate_about_y(vector pos, float rads) {
	float x = pos[2]*sin(rads) + pos[0]*cos(rads);
	float y = pos[1];
	float z = pos[2]*cos(rads) - pos[0]*sin(rads);
	return vector(x, y, z);
}

vector rotate_about_z(vector pos, float rads) {
	float x = pos[0]*cos(rads) - pos[1]*sin(rads);
	float y = pos[0]*sin(rads) + pos[1]*cos(rads);
	float z = pos[2];
	return vector(x, y, z);
}

/*
	model_width 	- Width of the model bounds in the x direction
	model_height	- Height of the model bounds in the y direction
	model_depth     - Depth the model bounds in the z direction
	
	brick_width 	- Width of the brick in the x direction
	brick_height	- Height of the brick in the y direction
	brick_depth     - Depth the brick in the z direction

	texture_width	- Width of the texture image in pixels
	texture_height  - Height of the texture image in pixels

	global_position - 3D Global position input to the shader
	out_uv          - 2D texture coordinate output of the shader
*/
shader simple_material(
	float model_width = 1.0,
	float model_height = 1.0,
	float model_depth = 1.0,
	float brick_width = 1.0,
	float brick_height = 1.0,
	float brick_depth = 1.0,
	int texture_width = 1,
	int texture_height = 1,
    vector global_position = vector(0.5, 0.5, 0.5),
    output vector out_uv = vector(0.0, 0.0, 0.0)
)
{	

	// The fluid simulation program uses the convention that the 'up' direction is the 
	// positive y direction. Blender uses the convention that positive z is the 'up' direction.
	// When the LEGO brick meshes are loaded into Blender, they are first rotated about the x-axis
	// by 90 degrees and then rotated about the z-axis by 90 degrees in order to face the right direction.
	// The global position must be rotated back so that the position matches the original position before
	// the mesh was rotated.
	//
	// Rotate global_position by -90 degrees about z axis and then by -90 degrees about x axis.
	float PI = 3.1415926535897;
	vector orig_position = rotate_about_z(global_position, -0.5*PI);
	orig_position = rotate_about_x(orig_position, -0.5*PI);

	int bi = (int)ceil(model_width / brick_width);
	int bj = (int)ceil(model_height / brick_height);
	int bk = (int)ceil(model_depth / brick_depth);
	
	vector brick_index = position_to_brick_index(orig_position, brick_width, brick_height, brick_depth);
	int flat_index = get_flat_index3d((int)brick_index[0], (int)brick_index[1], (int)brick_index[2], bi, bj);
	
	vector tex_index = get_unflattened_index2d(flat_index, texture_width);
	float texu = ((float)tex_index[0] + 0.5) / (float)texture_width;
	float texv = ((float)tex_index[1] + 0.5) / (float)texture_height;
	
	out_uv = vector(texu, texv, 0.0);
}
